{"ast":null,"code":"var path = require('path');\n\nvar fs = require('fs');\n\nvar assert = require(\"assert\"); // file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\n// @callback: called when finished.\n\n\nexports.mkdirs = function (_path, mode, callback) {\n  _path = exports.path.abspath(_path);\n\n  var dirs = _path.split(path.sep);\n\n  var walker = [dirs.shift()]; // walk\n  // @ds:  A list of directory names\n  // @acc: An accumulator of walked dirs\n  // @m:   The mode\n  // @cb:  The callback\n\n  var walk = function (ds, acc, m, cb) {\n    if (ds.length > 0) {\n      var d = ds.shift();\n      acc.push(d);\n      var dir = acc.join(path.sep); // look for dir on the fs, if it doesn't exist then create it, and \n      // continue our walk, otherwise if it's a file, we have a name\n      // collision, so exit.\n\n      fs.stat(dir, function (err, stat) {\n        // if the directory doesn't exist then create it\n        if (err) {\n          // 2 means it's wasn't there\n          if (err.errno == 2 || err.errno == 34) {\n            fs.mkdir(dir, m, function (erro) {\n              if (erro && erro.errno != 17 && erro.errno != 34) {\n                return cb(erro);\n              } else {\n                return walk(ds, acc, m, cb);\n              }\n            });\n          } else {\n            return cb(err);\n          }\n        } else {\n          if (stat.isDirectory()) {\n            return walk(ds, acc, m, cb);\n          } else {\n            return cb(new Error(\"Failed to mkdir \" + dir + \": File exists\\n\"));\n          }\n        }\n      });\n    } else {\n      return cb();\n    }\n  };\n\n  return walk(dirs, walker, mode, callback);\n}; // file.mkdirsSync\n//\n// Synchronus version of file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\n\n\nexports.mkdirsSync = function (_path, mode) {\n  if (_path[0] !== path.sep) {\n    _path = path.join(process.cwd(), _path);\n  }\n\n  var dirs = _path.split(path.sep);\n\n  var walker = [dirs.shift()];\n  dirs.reduce(function (acc, d) {\n    acc.push(d);\n    var dir = acc.join(path.sep);\n\n    try {\n      var stat = fs.statSync(dir);\n\n      if (!stat.isDirectory()) {\n        throw \"Failed to mkdir \" + dir + \": File exists\";\n      }\n    } catch (err) {\n      fs.mkdirSync(dir, mode);\n    }\n\n    return acc;\n  }, walker);\n}; // file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\n\n\nexports.walk = function (start, callback) {\n  fs.lstat(start, function (err, stat) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (stat.isDirectory()) {\n      fs.readdir(start, function (err, files) {\n        var coll = files.reduce(function (acc, i) {\n          var abspath = path.join(start, i);\n\n          if (fs.statSync(abspath).isDirectory()) {\n            exports.walk(abspath, callback);\n            acc.dirs.push(abspath);\n          } else {\n            acc.names.push(abspath);\n          }\n\n          return acc;\n        }, {\n          \"names\": [],\n          \"dirs\": []\n        });\n        return callback(null, start, coll.dirs, coll.names);\n      });\n    } else {\n      return callback(new Error(\"path: \" + start + \" is not a directory\"));\n    }\n  });\n}; // file.walkSync\n//\n// Synchronus version of file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\n\n\nexports.walkSync = function (start, callback) {\n  var stat = fs.statSync(start);\n\n  if (stat.isDirectory()) {\n    var filenames = fs.readdirSync(start);\n    var coll = filenames.reduce(function (acc, name) {\n      var abspath = path.join(start, name);\n\n      if (fs.statSync(abspath).isDirectory()) {\n        acc.dirs.push(name);\n      } else {\n        acc.names.push(name);\n      }\n\n      return acc;\n    }, {\n      \"names\": [],\n      \"dirs\": []\n    });\n    callback(start, coll.dirs, coll.names);\n    coll.dirs.forEach(function (d) {\n      var abspath = path.join(start, d);\n      exports.walkSync(abspath, callback);\n    });\n  } else {\n    throw new Error(\"path: \" + start + \" is not a directory\");\n  }\n};\n\nexports.path = {};\n\nexports.path.abspath = function (to) {\n  var from;\n\n  switch (to.charAt(0)) {\n    case \"~\":\n      from = process.env.HOME;\n      to = to.substr(1);\n      break;\n\n    case path.sep:\n      from = \"\";\n      break;\n\n    default:\n      from = process.cwd();\n      break;\n  }\n\n  return path.join(from, to);\n};\n\nexports.path.relativePath = function (base, compare) {\n  base = base.split(path.sep);\n  compare = compare.split(path.sep);\n\n  if (base[0] == \"\") {\n    base.shift();\n  }\n\n  if (compare[0] == \"\") {\n    compare.shift();\n  }\n\n  var l = compare.length;\n\n  for (var i = 0; i < l; i++) {\n    if (!base[i] || base[i] != compare[i]) {\n      return compare.slice(i).join(path.sep);\n    }\n  }\n\n  return \"\";\n};\n\nexports.path.join = function (head, tail) {\n  if (head == \"\") {\n    return tail;\n  } else {\n    return path.join(head, tail);\n  }\n};","map":{"version":3,"sources":["/home/kilberty/softcom/node_modules/file/lib/file.js"],"names":["path","require","fs","assert","exports","mkdirs","_path","mode","callback","abspath","dirs","split","sep","walker","shift","walk","ds","acc","m","cb","length","d","push","dir","join","stat","err","errno","mkdir","erro","isDirectory","Error","mkdirsSync","process","cwd","reduce","statSync","mkdirSync","start","lstat","readdir","files","coll","i","names","walkSync","filenames","readdirSync","name","forEach","to","from","charAt","env","HOME","substr","relativePath","base","compare","l","slice","head","tail"],"mappings":"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","sourcesContent":["var path = require('path');\nvar fs = require('fs');\nvar assert = require(\"assert\");\n\n// file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\n// @callback: called when finished.\nexports.mkdirs = function (_path, mode, callback) {\n  _path = exports.path.abspath(_path);\n\n  var dirs = _path.split(path.sep);\n  var walker = [dirs.shift()];\n\n  // walk\n  // @ds:  A list of directory names\n  // @acc: An accumulator of walked dirs\n  // @m:   The mode\n  // @cb:  The callback\n  var walk = function (ds, acc, m, cb) {\n    if (ds.length > 0) {\n      var d = ds.shift();\n\n      acc.push(d);\n      var dir = acc.join(path.sep);\n\n      // look for dir on the fs, if it doesn't exist then create it, and \n      // continue our walk, otherwise if it's a file, we have a name\n      // collision, so exit.\n      fs.stat(dir, function (err, stat) {\n        // if the directory doesn't exist then create it\n        if (err) {\n          // 2 means it's wasn't there\n          if (err.errno == 2 || err.errno == 34) {\n            fs.mkdir(dir, m, function (erro) {\n              if (erro && erro.errno != 17 && erro.errno != 34) {\n                return cb(erro);\n              } else {\n                return walk(ds, acc, m, cb);\n              }\n            });\n          } else {\n            return cb(err);\n          }\n        } else {\n          if (stat.isDirectory()) {\n            return walk(ds, acc, m, cb);\n          } else {\n            return cb(new Error(\"Failed to mkdir \" + dir + \": File exists\\n\"));\n          }\n        }\n      });\n    } else {\n      return cb();\n    }\n  };\n  return walk(dirs, walker, mode, callback);\n};\n\n// file.mkdirsSync\n//\n// Synchronus version of file.mkdirs\n//\n// Given a path to a directory, create it, and all the intermediate directories\n// as well\n// \n// @path: the path to create\n// @mode: the file mode to create the directory with:\n//    ex: file.mkdirs(\"/tmp/dir\", 755, function () {})\nexports.mkdirsSync = function (_path, mode) {\n  if (_path[0] !== path.sep) {\n    _path = path.join(process.cwd(), _path)\n  }\n\n  var dirs = _path.split(path.sep);\n  var walker = [dirs.shift()];\n\n  dirs.reduce(function (acc, d) {\n    acc.push(d);\n    var dir = acc.join(path.sep);\n    \n    try {\n      var stat = fs.statSync(dir);\n      if (!stat.isDirectory()) {\n        throw \"Failed to mkdir \" + dir + \": File exists\";\n      }\n    } catch (err) {\n      fs.mkdirSync(dir, mode);\n    }\n    return acc;\n  }, walker);\n};\n\n// file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\nexports.walk = function (start, callback) {\n  fs.lstat(start, function (err, stat) {\n    if (err) { return callback(err) }\n    if (stat.isDirectory()) {\n\n      fs.readdir(start, function (err, files) {\n        var coll = files.reduce(function (acc, i) {\n          var abspath = path.join(start, i);\n\n          if (fs.statSync(abspath).isDirectory()) {\n            exports.walk(abspath, callback);\n            acc.dirs.push(abspath);\n          } else {\n            acc.names.push(abspath);\n          }\n\n          return acc;\n        }, {\"names\": [], \"dirs\": []});\n\n        return callback(null, start, coll.dirs, coll.names);\n      });\n    } else {\n      return callback(new Error(\"path: \" + start + \" is not a directory\"));\n    }\n  });\n};\n\n// file.walkSync\n//\n// Synchronus version of file.walk\n//\n// Given a path to a directory, walk the fs below that directory\n// \n// @start: the path to startat\n// @callback: called for each new directory we enter\n//    ex: file.walk(\"/tmp\", function(error, path, dirs, name) {})\n//\n//    path is the current directory we're in\n//    dirs is the list of directories below it\n//    names is the list of files in it\n//\nexports.walkSync = function (start, callback) {\n  var stat = fs.statSync(start);\n\n  if (stat.isDirectory()) {\n    var filenames = fs.readdirSync(start);\n\n    var coll = filenames.reduce(function (acc, name) {\n      var abspath = path.join(start, name);\n\n      if (fs.statSync(abspath).isDirectory()) {\n        acc.dirs.push(name);\n      } else {\n        acc.names.push(name);\n      }\n\n      return acc;\n    }, {\"names\": [], \"dirs\": []});\n\n    callback(start, coll.dirs, coll.names);\n\n    coll.dirs.forEach(function (d) {\n      var abspath = path.join(start, d);\n      exports.walkSync(abspath, callback);\n    });\n\n  } else {\n    throw new Error(\"path: \" + start + \" is not a directory\");\n  }\n};\n\nexports.path = {};\n\nexports.path.abspath = function (to) {\n  var from;\n  switch (to.charAt(0)) {\n    case \"~\": from = process.env.HOME; to = to.substr(1); break\n    case path.sep: from = \"\"; break\n    default : from = process.cwd(); break\n  }\n  return path.join(from, to);\n}\n\nexports.path.relativePath = function (base, compare) {\n  base = base.split(path.sep);\n  compare = compare.split(path.sep);\n\n  if (base[0] == \"\") {\n    base.shift();\n  }\n\n  if (compare[0] == \"\") {\n    compare.shift();\n  }\n\n  var l = compare.length;\n\n  for (var i = 0; i < l; i++) {\n    if (!base[i] || (base[i] != compare[i])) {\n      return compare.slice(i).join(path.sep);\n    }\n  }\n\n  return \"\"\n};\n\nexports.path.join = function (head, tail) {\n  if (head == \"\") {\n    return tail;\n  } else {\n    return path.join(head, tail);\n  }\n};\n\n"]},"metadata":{},"sourceType":"script"}